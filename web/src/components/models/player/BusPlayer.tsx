/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/models/player/BusPlayer.glb -o src/components/models/player/BusPlayer.tsx -k -s -r public/ 
*/

import * as THREE from 'three'
import React, { useEffect, useRef } from 'react'
import { useGLTF, useKeyboardControls } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useFrame } from '@react-three/fiber'
import { useUserContext } from '@/context/UserContext'
import { Controls } from '@/consts'
import { RigidBody } from '@react-three/rapier'

type GLTFResult = GLTF & {
  nodes: {
    Plane143: THREE.Mesh
    Plane143_1: THREE.Mesh
    Plane143_2: THREE.Mesh
  }
  materials: {
    Glass: THREE.MeshPhysicalMaterial
    Base: THREE.MeshStandardMaterial
  }
}

type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>

export function BusPlayer(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF('/models/player/BusPlayer.glb') as GLTFResult

  const { cameraControlsRef } = useUserContext()
  const [sub, get] = useKeyboardControls<Controls>()
  // const [ref, api] = useRigidBody(() => ({
  //   mass: 1,
  //   type: 'dynamic',
  //   restitution: 2,
  //   position: [8.061, 0.393, -1.468],
  // }));

  const characterRef = useRef(null)

  const moveDirection = new THREE.Vector3();
  const speed = 5;
  const cameraOffset = new THREE.Vector3(0, 5, -5);
  const lerpFactor = 0.3; // Faktor interpolasi untuk pergerakan kamera

  useFrame((state, delta) => {
    const { forward, backward, left, right } = get(); // Mengasumsikan fungsi get() mengembalikan status tombol

    // Atur vektor berdasarkan input
    moveDirection.set(0, 0, 0);
    if (forward) moveDirection.z += 1;
    if (backward) moveDirection.z -= 1;
    if (left) moveDirection.x += 1;
    if (right) moveDirection.x -= 1;

    // Normalisasi untuk menghindari pergerakan lebih cepat secara diagonal
    moveDirection.normalize();

    // Terapkan kecepatan dan arah
    moveDirection.multiplyScalar(speed * delta);

    characterRef.current.position.add(moveDirection);

    if (characterRef.current && state.camera) {
      // Hitung posisi target kamera dengan menjaga kamera selalu berada di belakang karakter
      const targetPosition = characterRef.current.position.clone().add(cameraOffset);

      // Hitung posisi interpolasi untuk kamera
      const interpolatedPosition = new THREE.Vector3().lerpVectors(state.camera.position, targetPosition, lerpFactor);

      // Update posisi dan arah pandang kamera
      cameraControlsRef.current.setLookAt(
        interpolatedPosition.x, interpolatedPosition.y, interpolatedPosition.z,
        characterRef.current.position.x, characterRef.current.position.y, characterRef.current.position.z,
        true
      );
    }
  });
  return (
    <group {...props} dispose={null} >
      <RigidBody restitution={2} >

        <group ref={characterRef} name="Bus004" position={[8.061, 0.393, -1.468]} scale={0.472}>
          <mesh name="Plane143" castShadow geometry={nodes.Plane143.geometry} material={materials.Glass} />
          <mesh name="Plane143_1" castShadow geometry={nodes.Plane143_1.geometry} material={materials.Base} />
          <mesh name="Plane143_2" castShadow geometry={nodes.Plane143_2.geometry} material={materials.Glass} />
        </group>
      </RigidBody>
    </group>
  )
}

useGLTF.preload('/models/player/BusPlayer.glb')
